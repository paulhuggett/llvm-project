; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py UTC_ARGS: --version 5
; RUN: llc -mtriple=riscv32 -riscv-no-aliases -verify-machineinstrs \
; RUN:     -mattr=+v < %s \
; RUN:   | FileCheck -check-prefixes=ALL %s
; RUN: llc -mtriple=riscv32 -riscv-no-aliases -verify-machineinstrs \
; RUN:     -mattr=+v -mattr=+xkeysomnobeq < %s \
; RUN:   | FileCheck -check-prefixes=NOBEQ %s

define void @g(i32 %0) {
; ALL-LABEL: g:
; ALL:       # %bb.0:
; ALL-NEXT:    andi a0, a0, 1
; ALL-NEXT:    beq a0, zero, .LBB0_2
; ALL-NEXT:  # %bb.1:
; ALL-NEXT:    sb zero, 0(zero)
; ALL-NEXT:  .LBB0_2:
; ALL-NEXT:    jalr zero, 0(ra)
;
; NOBEQ-LABEL: g:
; NOBEQ:       # %bb.0:
; NOBEQ-NEXT:    andi a0, a0, 1
; NOBEQ-NEXT:    blt a0, zero, .LBB0_2
; NOBEQ-NEXT:  # %bb.1:
; NOBEQ-NEXT:    bge zero, a0, .LBB0_3
; NOBEQ-NEXT:  .LBB0_2:
; NOBEQ-NEXT:    sb zero, 0(zero)
; NOBEQ-NEXT:  .LBB0_3:
; NOBEQ-NEXT:    jalr zero, 0(ra)
; NOBEQ-LABE: g
  %2 = and i32 %0, 1
  %.not = icmp eq i32 %2, 0
  br i1 %.not, label %4, label %3
3:                                                ; preds = %1
  store i1 false, ptr null, align 1
  br label %4
4:                                                ; preds = %3, %1
  ret void
}

define i32 @h() {
; ALL-LABEL: h:
; ALL:       # %bb.0: # %entry
; ALL-NEXT:    addi a0, zero, 0
; ALL-NEXT:  # %bb.1: # %entry
; ALL-NEXT:    jal zero, .LBB1_3
; ALL-NEXT:  # %bb.2: # %cond_next18
; ALL-NEXT:    addi a0, zero, 1
; ALL-NEXT:  .LBB1_3: # %return
; ALL-NEXT:    jalr zero, 0(ra)
;
; NOBEQ-LABEL: h:
; NOBEQ:       # %bb.0: # %entry
; NOBEQ-NEXT:    addi a0, zero, 0
; NOBEQ-NEXT:  # %bb.1: # %entry
; NOBEQ-NEXT:    jal zero, .LBB1_4
; NOBEQ-NEXT:  # %bb.2: # %cond_next18
; NOBEQ-NEXT:    addi a0, zero, 1
; NOBEQ-NEXT:  .LBB1_3: # %return
; NOBEQ-NEXT:    jalr zero, 0(ra)
; NOBEQ-NEXT:  .LBB1_4: # %entry
; NOBEQ-NEXT:    jal zero, .LBB1_3
entry:
  %bothcond = or i1 false, true
  br i1 %bothcond, label %return, label %cond_next18

cond_next18:                                      ; preds = %entry
  br label %return

return:                                           ; preds = %cond_next18, %entry
  %retval.0 = phi i32 [ 1, %cond_next18 ], [ 0, %entry ]
  ret i32 %retval.0
}


; The expansion of atomicrmw max (when the A extension is disabled) includes a
; beq which branches to a BB with two phi nodes.
define i64 @j() {
; ALL-LABEL: j:
; ALL:       # %bb.0:
; ALL-NEXT:    addi sp, sp, -16
; ALL-NEXT:    .cfi_def_cfa_offset 16
; ALL-NEXT:    sw ra, 12(sp) # 4-byte Folded Spill
; ALL-NEXT:    .cfi_offset ra, -4
; ALL-NEXT:    lw a4, 0(zero)
; ALL-NEXT:    lw a1, 4(zero)
; ALL-NEXT:    jal zero, .LBB2_3
; ALL-NEXT:  .LBB2_1: # %atomicrmw.start
; ALL-NEXT:    # in Loop: Header=BB2_3 Depth=1
; ALL-NEXT:    slt a0, zero, a1
; ALL-NEXT:  .LBB2_2: # %atomicrmw.start
; ALL-NEXT:    # in Loop: Header=BB2_3 Depth=1
; ALL-NEXT:    sub a3, zero, a0
; ALL-NEXT:    and a2, a3, a4
; ALL-NEXT:    and a3, a3, a1
; ALL-NEXT:    sw a4, 0(sp)
; ALL-NEXT:    sw a1, 4(sp)
; ALL-NEXT:    addi a1, sp, 0
; ALL-NEXT:    addi a0, zero, 0
; ALL-NEXT:    addi a4, zero, 0
; ALL-NEXT:    addi a5, zero, 0
; ALL-NEXT:    call __atomic_compare_exchange_8
; ALL-NEXT:    lw a4, 0(sp)
; ALL-NEXT:    lw a1, 4(sp)
; ALL-NEXT:    bne a0, zero, .LBB2_5
; ALL-NEXT:  .LBB2_3: # %atomicrmw.start
; ALL-NEXT:    # =>This Inner Loop Header: Depth=1
; ALL-NEXT:    bne a1, zero, .LBB2_1
; ALL-NEXT:  # %bb.4: # in Loop: Header=BB2_3 Depth=1
; ALL-NEXT:    sltu a0, zero, a4
; ALL-NEXT:    jal zero, .LBB2_2
; ALL-NEXT:  .LBB2_5: # %atomicrmw.end
; ALL-NEXT:    addi a0, a4, 0
; ALL-NEXT:    lw ra, 12(sp) # 4-byte Folded Reload
; ALL-NEXT:    .cfi_restore ra
; ALL-NEXT:    addi sp, sp, 16
; ALL-NEXT:    .cfi_def_cfa_offset 0
; ALL-NEXT:    jalr zero, 0(ra)
;
; NOBEQ-LABEL: j:
; NOBEQ:       # %bb.0:
; NOBEQ-NEXT:    addi sp, sp, -16
; NOBEQ-NEXT:    .cfi_def_cfa_offset 16
; NOBEQ-NEXT:    sw ra, 12(sp) # 4-byte Folded Spill
; NOBEQ-NEXT:    .cfi_offset ra, -4
; NOBEQ-NEXT:    lw a4, 0(zero)
; NOBEQ-NEXT:    lw a1, 4(zero)
; NOBEQ-NEXT:  .LBB2_1: # %atomicrmw.start
; NOBEQ-NEXT:    # =>This Inner Loop Header: Depth=1
; NOBEQ-NEXT:    bne a1, zero, .LBB2_2
; NOBEQ-NEXT:    jal zero, .LBB2_3
; NOBEQ-NEXT:  .LBB2_2: # %atomicrmw.start
; NOBEQ-NEXT:    # in Loop: Header=BB2_1 Depth=1
; NOBEQ-NEXT:    slt a0, zero, a1
; NOBEQ-NEXT:    jal zero, .LBB2_4
; NOBEQ-NEXT:  .LBB2_3: # in Loop: Header=BB2_1 Depth=1
; NOBEQ-NEXT:    sltu a0, zero, a4
; NOBEQ-NEXT:  .LBB2_4: # %atomicrmw.start
; NOBEQ-NEXT:    # in Loop: Header=BB2_1 Depth=1
; NOBEQ-NEXT:    sub a3, zero, a0
; NOBEQ-NEXT:    and a2, a3, a4
; NOBEQ-NEXT:    and a3, a3, a1
; NOBEQ-NEXT:    sw a4, 0(sp)
; NOBEQ-NEXT:    sw a1, 4(sp)
; NOBEQ-NEXT:    addi a1, sp, 0
; NOBEQ-NEXT:    addi a0, zero, 0
; NOBEQ-NEXT:    addi a4, zero, 0
; NOBEQ-NEXT:    addi a5, zero, 0
; NOBEQ-NEXT:    call __atomic_compare_exchange_8
; NOBEQ-NEXT:    lw a4, 0(sp)
; NOBEQ-NEXT:    lw a1, 4(sp)
; NOBEQ-NEXT:    blt a0, zero, .LBB2_6
; NOBEQ-NEXT:  # %bb.5: # %atomicrmw.start
; NOBEQ-NEXT:    # in Loop: Header=BB2_1 Depth=1
; NOBEQ-NEXT:    bge zero, a0, .LBB2_1
; NOBEQ-NEXT:  .LBB2_6: # %atomicrmw.end
; NOBEQ-NEXT:    addi a0, a4, 0
; NOBEQ-NEXT:    lw ra, 12(sp) # 4-byte Folded Reload
; NOBEQ-NEXT:    .cfi_restore ra
; NOBEQ-NEXT:    addi sp, sp, 16
; NOBEQ-NEXT:    .cfi_def_cfa_offset 0
; NOBEQ-NEXT:    jalr zero, 0(ra)

  %1 = atomicrmw max ptr null, i64 0 monotonic, align 8
  ret i64 %1
}


define <vscale x 1 x i8> @k(i1 %c1, <vscale x 1 x i8> %0) {
; ALL-LABEL: k:
; ALL:       # %bb.0: # %entry
; ALL-NEXT:    andi a0, a0, 1
; ALL-NEXT:    beq a0, zero, .LBB3_3
; ALL-NEXT:  # %bb.1: # %block1
; ALL-NEXT:    beq a0, zero, .LBB3_3
; ALL-NEXT:  # %bb.2: # %block2
; ALL-NEXT:    jalr zero, 0(ra)
; ALL-NEXT:  .LBB3_3: # %block3
; ALL-NEXT:    vsetvli a0, zero, e8, mf8, ta, ma
; ALL-NEXT:    vmv.v.i v8, 0
; ALL-NEXT:    jalr zero, 0(ra)
;
; NOBEQ-LABEL: k:
; NOBEQ:       # %bb.0: # %entry
; NOBEQ-NEXT:    andi a0, a0, 1
; NOBEQ-NEXT:    bne a0, zero, .LBB3_1
; NOBEQ-NEXT:    jal zero, .LBB3_4
; NOBEQ-NEXT:  .LBB3_1: # %block1
; NOBEQ-NEXT:    blt a0, zero, .LBB3_3
; NOBEQ-NEXT:  # %bb.2: # %block1
; NOBEQ-NEXT:    bge zero, a0, .LBB3_4
; NOBEQ-NEXT:  .LBB3_3: # %block2
; NOBEQ-NEXT:    jalr zero, 0(ra)
; NOBEQ-NEXT:  .LBB3_4: # %block3
; NOBEQ-NEXT:    vsetvli a0, zero, e8, mf8, ta, ma
; NOBEQ-NEXT:    vmv.v.i v8, 0
; NOBEQ-NEXT:    jalr zero, 0(ra)

entry:
  br i1 %c1, label %block1, label %block2

block1:                                           ; preds = %entry
  br i1 %c1, label %block2, label %block3

block2:                                           ; preds = %block1, %entry
  %c = phi <vscale x 1 x i8> [ zeroinitializer, %entry ], [ %0, %block1 ]
  ret <vscale x 1 x i8> %c

block3:                                           ; preds = %block1
  ret <vscale x 1 x i8> zeroinitializer
}

